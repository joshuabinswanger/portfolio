---
import type { ImageMetadata } from 'astro';
import { Picture } from 'astro:assets';
import "../styles/global.css";

interface Props {
    grid_three: string;
    margin_top: string;
    to: string;
    title: string;
    tools: string;
    altText: string;
    imagePath: string;
    onhover_imagePath: string;
    
  };
  
// Get component props from Astro.props
const { grid_three, margin_top, text_size, to, title, tools, imagePath, onhover_imagePath } = Astro.props;

//Import all image paths to check against the passed in strings
const images = import.meta.glob<{ default: ImageMetadata }>('/src/assets/**/*.{jpeg,jpg,png,gif,webp}');
if (!images[imagePath]) throw new Error(`"${imagePath}" does not exist in glob: "src/assets/**/*.{jpeg,jpg,png,gif,webp}"`);
---




<div id="Image_Wrapper" style="height:auto;" >
  <div id="Spacer" style="pointer-events: none;">
    {/*this is an empty div*/}
  </div>

  <div id="ImageAndText_Wrapper" class:list={"hidden"} style="display: grid; pointer-events: auto;">
    <div id="GalleryImage">
       <a href={to}><Picture src={images[imagePath]()} alt="empty" style="width: 100%; height: auto;"></a> 
    </div>

    <div id= "TextGrid">
      <div id="Image_Title">{title}</div>
      <div id="Image_Tools">{tools}</div>  
    </div>

  </div>

  <div id="Spacer" style="pointer-events: none;">
  {/*this is an empty div*/}
  </div>
</div>






<style define:vars={{ grid_three, margin_top }}>
@import "../styles/global.css";

/* Text Size*/

  #Image_Title{
    font-size: var(--font-size-normal);

    @media (--bp-mobile){
      font-size: var(--font-size-mobile);
    }
    
    @media (--bp-tablet){
      font-size: var(--font-size-tablet);
    }

    @media (--bp-desktop-wide){
      font-size: var(--font-size-desktop-wide);
    }
  }

  #Image_Tools{
    text-align: end;
    font-size: var(--font-size-normal);


    @media (--bp-mobile){
      font-size: var(--font-size-mobile);
    }

    @media (--bp-tablet){
      font-size: var(--font-size-tablet);
    }

    @media (--bp-desktop-wide){
      font-size: var(--font-size-desktop-wide);
    }
  }

/*Gallery Row Wrapper */

  #Image_Wrapper { 
    display: grid; 
    grid-template-columns: var(--grid_three); 
    margin-top: var(--margin_top);

    @media (--bp-mobile) {
      grid-template-columns: 1fr; 
      margin-top: 1rem;
    }
  }



/*Gallery Text Grid */
#TextGrid {
  display: grid; 
   margin-top: 2px;
  grid-template-columns: 1fr 1fr;
}

/*Fade */

.hidden{
  opacity: 0.22;
  filter: contrast(0.66) sepia(.8) blur(2px) grayscale(0.8);
  transition: all 0.66s;
  transform: translateY(10%);
}

.show {
  opacity: 1;
  filter:  contrast(1) brightness(1) sepia(0) blur(0px) grayscale(0);
  transform: translateY(0);
}



</style>

<script>

let options = {
  rootMargin: "100px 0px -88px 0px",
};

	// Define the behaviour for our new type of HTML element.
	const observer = new IntersectionObserver((entries) => {  
			entries.forEach((entry) => {
				console.log(entry)
				if (entry.isIntersecting){
					entry.target.classList.add("show");
				}
				else	{
					entry.target.classList.remove("show");
				}
	
		});
	 }, options);
	
	const fadeElements = document.querySelectorAll(".hidden");
	fadeElements.forEach((el) => observer.observe(el));

	
</script>